<!DOCTYPE html>
<!-- saved from url=(0081)file:///C:/Users/jacob/Downloads/Tactical%20Aircraft%20Simulator_V2_Rotation.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactical Aircraft Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Control Panels */
        .control-panel {
            width: 300px;
            padding: 20px;
            overflow-y: auto;
            border: 2px solid #333;
        }

        .blue-panel {
            background: linear-gradient(180deg, #001a33 0%, #002244 100%);
            border-color: #0066cc;
        }

        .red-panel {
            background: linear-gradient(180deg, #330011 0%, #442200 100%);
            border-color: #cc3300;
        }

        .panel-title {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 5px;
        }

        .blue-panel .panel-title {
            background-color: #0066cc;
        }

        .red-panel .panel-title {
            background-color: #cc3300;
        }

        /* Grid Container */
        .grid-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #000;
            padding: 80px 20px 20px 20px;
        }

        .grid-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #333;
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .simulation-info {
            display: flex;
            gap: 20px;
            margin-left: 20px;
            font-size: 0.9em;
            color: #333;
        }

        #tactical-grid {
            border: 2px solid #444;
            background-color: #111;
            cursor: crosshair;
            display: block;
        }

        .grid-info {
            margin-top: 15px;
            text-align: center;
            font-size: 0.9em;
            color: #ccc;
        }

        .grid-info div {
            margin: 5px 0;
        }

        /* Controls */
        .aircraft-section, .formation-controls, .distance-display {
            margin-bottom: 25px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .aircraft-section h3, .formation-controls h3, .distance-display h3 {
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #fff;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #333;
            color: #fff;
            font-size: 0.9em;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #0088ff;
            box-shadow: 0 0 5px rgba(0, 136, 255, 0.3);
        }

        /* Formation positioning controls */
        .position-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .position-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .position-row input[type="checkbox"] {
            width: auto;
        }

        .position-row input[type="number"] {
            flex: 1;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #0088ff;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0066cc;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: #666;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #555;
        }

        .btn-danger {
            background-color: #cc3300;
            color: white;
        }

        .btn-danger:hover {
            background-color: #aa2200;
        }

        .btn-blue {
            background-color: #0066cc;
            color: white;
            width: 100%;
        }

        .btn-blue:hover {
            background-color: #0055aa;
        }

        .btn-red {
            background-color: #cc3300;
            color: white;
            width: 100%;
        }

        .btn-red:hover {
            background-color: #aa2200;
        }

        /* Formation Aircraft List */
        .formation-aircraft {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .manual-controls {
            margin-top: 10px;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            display: none;
        }

        .manual-controls.active {
            display: block;
        }

        .manual-control-row {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
        }

        .manual-control-row label {
            min-width: 60px;
            font-size: 0.8em;
        }

        .manual-control-row input[type="number"] {
            width: 60px;
            padding: 2px 4px;
        }

        .manual-control-row select {
            width: 80px;
            padding: 2px 4px;
        }

        .formation-aircraft-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .formation-aircraft-name {
            font-weight: bold;
            color: #fff;
        }

        .remove-aircraft {
            background-color: #cc3300;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .remove-aircraft:hover {
            background-color: #aa2200;
        }

        .override-checkbox {
            margin-right: 5px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #333;
            margin: 10% auto;
            padding: 30px;
            border-radius: 10px;
            width: 500px;
            color: #fff;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        /* Distance Display */
        .distance-item {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 0.85em;
            display: flex;
            justify-content: space-between;
        }

        .distance-value {
            font-weight: bold;
            color: #00ff88;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .control-panel {
                width: 250px;
            }
        }

        @media (max-width: 1000px) {
            .container {
                flex-direction: column;
                height: auto;
                overflow-y: auto;
            }
            
            .control-panel {
                width: 100%;
                height: auto;
                max-height: none;
            }
            
            .grid-container {
                height: 60vh;
            }
            
            #tactical-grid {
                width: 90vw;
                height: 50vh;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #222;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Blue Controls (Left Side) -->
        <div class="control-panel blue-panel">
            <h2 class="panel-title">BLUE FORCE</h2>
            
            <div class="aircraft-section">
                <h3>Blue 1 (Lead)</h3>
                <div class="control-group">
                    <label>Turn Command:</label>
                    <select id="blue1-turn">
                        <option value="0">Straight</option>
                        <option value="45">45Â° Left</option>
                        <option value="-45">45Â° Right</option>
                        <option value="90">90Â° Left</option>
                        <option value="-90">90Â° Right</option>
			<option value="135">135Â° Left</option>
			<option value="-135">135Â° Right</option>
                        <option value="180">180Â° Left</option>
			<option value="-180">180Â° Right</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Speed (nm/min):</label>
                    <input type="number" id="blue1-speed" value="10" min="1" max="50" step="0.1">
                </div>
            </div>

            <div class="formation-controls">
                <h3>Formation Aircraft</h3>
                <button id="add-blue-aircraft" class="btn btn-blue">Add Aircraft</button>
                <div id="blue-formation-list"></div>
            </div>

            <div class="distance-display">
                <h3>Distances</h3>
                <div id="blue-distances"><div class="distance-item">
                            <span>Blue 1 â†’ Red 1</span>
                            <span class="distance-value">65.0 nm</span>
                        </div></div>
            </div>
        </div>

        <!-- Center Grid -->
        <div class="grid-container">
            <div class="grid-controls">
                <button id="advance-btn" class="btn btn-primary">Advance</button>
                <button id="undo-btn" class="btn btn-secondary">Undo</button>
                <button id="reset-btn" class="btn btn-danger">Reset</button>
                <button id="clear-trails-btn" class="btn btn-secondary">Clear Trails</button>
                <button id="reposition-btn" class="btn btn-secondary">Reposition Forces</button>
		<div style="display: flex; align-items: center; gap: 10px;">
  			<label for="canvas-rotation-slider" style="color: black;">Rotation:</label>
  			<input type="range" id="canvas-rotation-slider" min="0" max="359" value="0">
  			<span id="rotation-angle-label" style="color: black;">16Â°</span>
		</div>
		<div style="display: flex; align-items: center; gap: 10px;">
  			<label for="separation-slider" style="color: black;">Separation:</label>
  			<input type="range" id="separation-slider" min="10" max="150" value="65" step="1">
  			<span id="separation-label" style="color: black;">65 nm</span>
		</div>
		<div style="display: flex; align-items: center; gap: 10px;">
  			<label for="time-step-selector" style="color: black;">Step Time:</label>
  			<select id="time-step-selector">
    			<option value="5">5s</option>
    			<option value="10">10s</option>
   			<option value="30" selected>30s</option>
 		</select>
		</div>
	

<!-- Drawing History Panel -->
<!-- Drawing History Panel (Initially Hidden) -->
<div id="drawing-history" style="
    position: absolute;
    bottom: 00px;
    right: 40px;
    width: 220px;
    background-color: rgba(17, 17, 17, 0.95);
    color: white;
    padding: 10px;
    border-radius: 8px;
    border: 2px solid #444;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 14px;
    display: none; /* start hidden */
    z-index: 999;
">
    <strong style="display: block; margin-bottom: 8px;">Drawings:</strong>
    <div id="history-list" style="display: flex; flex-direction: column; gap: 5px;"></div>
</div>



                <div class="simulation-info">
                    <span>Time: <span id="sim-time">0</span> min (30s steps)</span>
                    <span>Step: <span id="sim-step">0</span></span>
                </div>
            </div>
            <canvas id="tactical-grid" width="1000" height="1000"></canvas>
<!-- Shape Selector Under Grid -->
<!-- Floating Drawing Controls Over Canvas -->
<div id="drawing-controls" style="
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(34, 34, 34, 0.95);
    padding: 12px 20px;
    border-radius: 8px;
    display: flex;
    gap: 10px;
    align-items: center;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    border: 2px solid #444;
    z-index: 999;
">
    <label for="shape-selector">Select Shape:</label>
    <select id="shape-selector" class="btn btn-secondary" style="padding: 6px 10px;">
        <option value="line" selected>Line</option>
        <option value="circle">Circle</option>
        <option value="rectangle">Rectangle</option>
        <option value="arc">Arc</option>
    </select>
    <button id="toggle-history-btn" class="btn btn-secondary">Show History</button>
    <button id="save-shapes-btn" class="btn btn-primary">Save</button>
    <input type="file" id="load-shapes-input" style="display: none;">
    <button id="load-shapes-btn" class="btn btn-primary">Load</button>
</div>
	
            <div class="grid-info">
                <div>100nm Ã— 100nm Grid (5nm per division)</div>
                <div>Mouse Position: <span id="mouse-coords">-23.0, 5.0</span></div>
                <div>Selected Distance: <span id="selected-distance">---</span></div>
                <div>Hold Ctrl + Drag to measure distance</div>
            </div>
        </div>

        <!-- Red Controls (Right Side) -->
        <div class="control-panel red-panel">
            <h2 class="panel-title">RED FORCE</h2>
            
            <div class="aircraft-section">
                <h3>Red 1 (Lead)</h3>
                <div class="control-group">
                    <label>Turn Command:</label>
                    <select id="red1-turn">
                         <option value="0">Straight</option>
                        <option value="45">45Â° Left</option>
                        <option value="-45">45Â° Right</option>
                        <option value="90">90Â° Left</option>
                        <option value="-90">90Â° Right</option>
			<option value="135">135Â° Left</option>
			<option value="-135">135Â° Right</option>
                        <option value="180">180Â° Left</option>
			<option value="-180">180Â° Right</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Speed (nm/min):</label>
                    <input type="number" id="red1-speed" value="10" min="1" max="50" step="0.1">
                </div>
            </div>

            <div class="formation-controls">
                <h3>Formation Aircraft</h3>
                <button id="add-red-aircraft" class="btn btn-red">Add Aircraft</button>
                <div id="red-formation-list"></div>
            </div>

            <div class="distance-display">
                <h3>Distances</h3>
                <div id="red-distances"><div class="distance-item">
                            <span>Red 1 â†’ Blue 1</span>
                            <span class="distance-value">65.0 nm</span>
                        </div></div>
            </div>
        </div>
    </div>

    <!-- Add Aircraft Modal -->
    <div id="add-aircraft-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>Add Formation Aircraft</h3>
            <div class="control-group">
                <label>Aircraft ID:</label>
                <input type="text" id="new-aircraft-id" placeholder="e.g., Blue 2">
            </div>
            
            <div class="position-controls">
                <h4>Position Configuration:</h4>
                
                <div class="position-row">
                    <input type="checkbox" id="use-azimuth">
                    <label for="use-azimuth">Azimuth (Left/Right):</label>
                    <input type="number" id="azimuth-distance" value="5" min="0.1" max="50" step="0.1" disabled="">
                    <select id="azimuth-direction" disabled="">
                        <option value="positive">Right</option>
                        <option value="negative">Left</option>
                    </select>
                </div>
                
                <div class="position-row">
                    <input type="checkbox" id="use-depth">
                    <label for="use-depth">Depth (Front/Back):</label>
                    <input type="number" id="depth-distance" value="5" min="0.1" max="50" step="0.1" disabled="">
                    <select id="depth-direction" disabled="">
                        <option value="positive">Front</option>
                        <option value="negative">Back</option>
                    </select>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="confirm-add-aircraft" class="btn btn-primary">Add</button>
                <button id="cancel-add-aircraft" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * Physics calculations for tactical aircraft simulation
         */
        class PhysicsEngine {
            constructor() {
                this.EARTH_RADIUS_NM = 3440.065;
                this.G_FORCE_4G = 4;
                this.GRAVITY_FT_S2 = 32.174;
                this.NM_TO_FEET = 6076.12;
                this.KNOTS_TO_FT_MIN = 101.269;
            }

            calculateTurnRadius(speedNmPerMin) {
                const speedFtPerMin = speedNmPerMin * this.NM_TO_FEET;
                const speedFtPerSec = speedFtPerMin / 60;
                const radiusFeet = (speedFtPerSec * speedFtPerSec) / (this.GRAVITY_FT_S2 * this.G_FORCE_4G);
                return radiusFeet / this.NM_TO_FEET;
            }

            calculateFixedDistanceTurnPath(currentPos, currentHeading, newHeading, totalDistance = 5) {
                const turnRadius = this.calculateTurnRadius(10); // Use fixed 10nm/min for turn radius calculation
                const headingDiff = this.shortestAngleDiff(currentHeading, newHeading);

                
                // If no turn needed, go straight
                if (Math.abs(headingDiff) < 1) {
                    const finalX = currentPos.x + Math.cos(this.degreesToRadians(currentHeading)) * totalDistance;
                    const finalY = currentPos.y + Math.sin(this.degreesToRadians(currentHeading)) * totalDistance;
                    return {
                        finalPosition: { x: finalX, y: finalY },
                        waypoints: [{ x: finalX, y: finalY }],
                        actualHeading: currentHeading
                    };
                }

                const turnDirection = headingDiff > 0 ? 1 : -1;
                const turnAngleRad = Math.abs(this.degreesToRadians(headingDiff));
                
                // Calculate turn center
                const centerOffset = turnDirection * Math.PI / 2;
                const centerX = currentPos.x + turnRadius * Math.cos(this.degreesToRadians(currentHeading) + centerOffset);
                const centerY = currentPos.y + turnRadius * Math.sin(this.degreesToRadians(currentHeading) + centerOffset);
                
                // Calculate arc length for the turn
                const arcLength = turnRadius * turnAngleRad;
                
                const waypoints = [];
                
                if (arcLength >= totalDistance) {
                    // Turn uses all available distance
                    const partialTurnAngle = totalDistance / turnRadius;
                    const currentTurnAngle = partialTurnAngle * turnDirection;
                    const pointAngle = this.degreesToRadians(currentHeading) + centerOffset + Math.PI + currentTurnAngle;
                    
                    const finalX = centerX + turnRadius * Math.cos(pointAngle);
                    const finalY = centerY + turnRadius * Math.sin(pointAngle);
                    const finalHeading = this.normalizeAngle(currentHeading + this.radiansToDegrees(partialTurnAngle) * turnDirection);
                    
                    waypoints.push({ x: finalX, y: finalY });
                    
                    return {
                        finalPosition: { x: finalX, y: finalY },
                        waypoints: waypoints,
                        actualHeading: finalHeading
                    };
                } else {
                    // Complete turn then go straight
                    const numTurnSegments = Math.max(3, Math.floor(Math.abs(headingDiff) / 15));
                    
                    // Add turn waypoints
                    for (let i = 1; i <= numTurnSegments; i++) {
                        const progress = i / numTurnSegments;
                        const currentTurnAngle = turnAngleRad * progress * turnDirection;
                        const pointAngle = this.degreesToRadians(currentHeading) + centerOffset + Math.PI + currentTurnAngle;
                        
                        const pointX = centerX + turnRadius * Math.cos(pointAngle);
                        const pointY = centerY + turnRadius * Math.sin(pointAngle);
                        
                        waypoints.push({ x: pointX, y: pointY });
                    }
                    
                    // Calculate remaining straight distance
                    const remainingDistance = totalDistance - arcLength;
                    const finalX = waypoints[waypoints.length - 1].x + 
                                  Math.cos(this.degreesToRadians(newHeading)) * remainingDistance;
                    const finalY = waypoints[waypoints.length - 1].y + 
                                  Math.sin(this.degreesToRadians(newHeading)) * remainingDistance;
                    
                    waypoints.push({ x: finalX, y: finalY });
                    
                    return {
                        finalPosition: { x: finalX, y: finalY },
                        waypoints: waypoints,
                        actualHeading: newHeading
                    };
                }
            }

            calculateStraightMovement(position, heading, speed) {
                const headingRad = this.degreesToRadians(heading);
                return {
                    x: position.x + Math.cos(headingRad) * speed,
                    y: position.y + Math.sin(headingRad) * speed
                };
            }

            calculateDistance(pos1, pos2) {
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            calculateBearing(from, to) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const bearing = this.radiansToDegrees(Math.atan2(dy, dx));
                return this.normalizeAngle(bearing);
            }

            calculateFormationPosition(leadPos, leadHeading, azimuthDistance, azimuthDirection, depthDistance, depthDirection) {
                let finalX = leadPos.x;
                let finalY = leadPos.y;

                // Apply azimuth offset (perpendicular to heading direction)
                // If heading west (270Â°), azimuth is north/south
                // If heading north (0Â°), azimuth is east/west
                // If heading east (90Â°), azimuth is north/south
                // If heading south (180Â°), azimuth is east/west
                if (azimuthDistance > 0) {
                    const azimuthMultiplier = azimuthDirection === 'positive' ? 1 : -1;
                    const azimuthAngle = leadHeading + (90 * azimuthMultiplier);
                    const azimuthRad = this.degreesToRadians(azimuthAngle);
                    finalX += Math.cos(azimuthRad) * azimuthDistance;
                    finalY += Math.sin(azimuthRad) * azimuthDistance;
                }

                // Apply depth offset (along heading direction - front/back)
                if (depthDistance > 0) {
                    const depthMultiplier = depthDirection === 'positive' ? 1 : -1;
                    const depthAngle = leadHeading + (depthMultiplier === 1 ? 0 : 180);
                    const depthRad = this.degreesToRadians(depthAngle);
                    finalX += Math.cos(depthRad) * depthDistance;
                    finalY += Math.sin(depthRad) * depthDistance;
                }

                return { x: finalX, y: finalY };
            }

            degreesToRadians(degrees) {
                return degrees * Math.PI / 180;
            }

            radiansToDegrees(radians) {
                return radians * 180 / Math.PI;
            }

            normalizeAngle(angle) {
                while (angle < 0) angle += 360;
                while (angle >= 360) angle -= 360;
                return angle;
            }
	    
	    shortestAngleDiff(from, to) {
    		let diff = to - from;
    		if (diff > 180) diff -= 360;
    		if (diff < -180) diff += 360;
    		return diff;
	    }
        
}

        /**
         * Grid rendering and coordinate system management
         */
        class TacticalGrid {
            constructor(canvas, context) {
                this.canvas = canvas;
                this.ctx = context;
                this.rotationDegrees = 0

                this.GRID_SIZE_NM = 100;
                this.SUBDIVISION_NM = 5;
                this.GRID_DIVISIONS = this.GRID_SIZE_NM / this.SUBDIVISION_NM;
                
                this.canvasWidth = canvas.width;
                this.canvasHeight = canvas.height;
                
                this.scale = Math.min(this.canvasWidth, this.canvasHeight) / this.GRID_SIZE_NM;
                
                this.centerX = this.canvasWidth / 2;
                this.centerY = this.canvasHeight / 2;
                
                this.selectedPoints = [];
                this.mousePos = { x: 0, y: 0 };
                this.isDragging = false;
                this.dragStart = null;
                this.dragEnd = null;
		this.shapes = [];
		this.currentShape = null;
		this.drawingMode = 'line'; // 'line', 'circle', 'rectangle', 'arc'
		this.selectedShapeIndex = null;
		this.shapeDragOffset = { x: 0, y: 0 };


                this.setupMouseTracking();
            }
		setRotation(degrees) {
    		this.rotationDegrees = degrees;
	    }

            nmToCanvas(nmX, nmY) {
                return {
                    x: this.centerX + (nmX * this.scale),
                    y: this.centerY - (nmY * this.scale)
                };
            }

            canvasToNm(canvasX, canvasY) {
                return {
                    x: (canvasX - this.centerX) / this.scale,
                    y: (this.centerY - canvasY) / this.scale
                };
            }

          render() {
    //Clear before any transforms
    this.clearCanvas();

    //Apply rotation
    this.ctx.save();
    this.ctx.translate(this.centerX, this.centerY);
    this.ctx.rotate(-this.rotationDegrees * Math.PI / 180);
    this.ctx.translate(-this.centerX, -this.centerY);

    //Draw grid
    this.drawGrid();
    this.drawAxes();
    this.drawScale();
    this.drawOrigin();
this.shapes.forEach(shape => this.drawShape(shape));
if (this.isDragging && this.dragStart && this.dragEnd) {
    this.drawShape({ type: this.drawingMode, start: this.dragStart, end: this.dragEnd }, true);
}


    if (this.isDragging && this.dragStart && this.dragEnd) {
        this.drawDistanceLine(this.dragStart, this.dragEnd);
    }

    this.ctx.restore();
}



            clearCanvas() {
                this.ctx.fillStyle = '#111111';
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            }

            drawGrid() {
                this.ctx.strokeStyle = '#333333';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([]);

                const pixelsPerDivision = this.scale * this.SUBDIVISION_NM;
                const halfGrid = this.GRID_DIVISIONS / 2;

                // Draw vertical lines
                for (let i = -halfGrid; i <= halfGrid; i++) {
                    const x = this.centerX + (i * pixelsPerDivision);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.centerY - (halfGrid * pixelsPerDivision));
                    this.ctx.lineTo(x, this.centerY + (halfGrid * pixelsPerDivision));
                    this.ctx.stroke();
                }

                // Draw horizontal lines
                for (let i = -halfGrid; i <= halfGrid; i++) {
                    const y = this.centerY + (i * pixelsPerDivision);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.centerX - (halfGrid * pixelsPerDivision), y);
                    this.ctx.lineTo(this.centerX + (halfGrid * pixelsPerDivision), y);
                    this.ctx.stroke();
                }

                // Draw major grid lines (every 25nm)
                this.ctx.strokeStyle = '#555555';
                this.ctx.lineWidth = 2;
                
                const majorDivisionPixels = this.scale * 25;
                const majorHalfGrid = 2;

                // Major vertical lines
                for (let i = -majorHalfGrid; i <= majorHalfGrid; i++) {
                    const x = this.centerX + (i * majorDivisionPixels);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.centerY - (halfGrid * pixelsPerDivision));
                    this.ctx.lineTo(x, this.centerY + (halfGrid * pixelsPerDivision));
                    this.ctx.stroke();
                }

                // Major horizontal lines
                for (let i = -majorHalfGrid; i <= majorHalfGrid; i++) {
                    const y = this.centerY + (i * majorDivisionPixels);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.centerX - (halfGrid * pixelsPerDivision), y);
                    this.ctx.lineTo(this.centerX + (halfGrid * pixelsPerDivision), y);
                    this.ctx.stroke();
                }
            }

            drawAxes() {
                // Remove axis lines - just keep the grid
            }

            drawScale() {
                // Remove scale labels - just keep corner info
                this.ctx.textAlign = 'left';
                this.ctx.font = '10px monospace';
                this.ctx.fillStyle = '#999999';
                this.ctx.fillText('100nm Ã— 100nm Grid', 10, 20);
                this.ctx.fillText('5nm per division', 10, 35);
            }

            drawOrigin() {
                // Remove origin marker for cleaner grid
            }
drawShape(shape, preview = false) {
    const { start, end, type } = shape;
    const ctx = this.ctx;
    const startPx = this.nmToCanvas(start.x, start.y);
    const endPx = this.nmToCanvas(end.x, end.y);
    const dx = end.x - start.x;
    const dy = end.y - start.y;

    ctx.strokeStyle = preview ? '#00ff00' : '#ffaa00';
    ctx.fillStyle = '#000';
    ctx.lineWidth = 2;
    ctx.setLineDash(preview ? [4, 4] : []);

    ctx.beginPath();
    if (type === 'line') {
        ctx.moveTo(startPx.x, startPx.y);
        ctx.lineTo(endPx.x, endPx.y);
        ctx.stroke();
        const dist = Math.sqrt(dx*dx + dy*dy).toFixed(1);
        ctx.fillText(`${dist} nm`, (startPx.x + endPx.x)/2, (startPx.y + endPx.y)/2 - 5);
    } else if (type === 'circle') {
        const radius = Math.sqrt(dx*dx + dy*dy);
        ctx.arc(startPx.x, startPx.y, radius * this.scale, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fillText(`r=${radius.toFixed(1)} nm`, startPx.x + 5, startPx.y - 5);
    } else if (type === 'rectangle') {
    const gridStart = this.nmToCanvas(start.x, start.y);
    const gridEnd = this.nmToCanvas(end.x, end.y);

    const topLeft = {
        x: Math.min(gridStart.x, gridEnd.x),
        y: Math.min(gridStart.y, gridEnd.y)
    };
    const widthPixels = Math.abs(gridEnd.x - gridStart.x);
    const heightPixels = Math.abs(gridEnd.y - gridStart.y);

    ctx.strokeRect(topLeft.x, topLeft.y, widthPixels, heightPixels);

    const widthNM = Math.abs(end.x - start.x).toFixed(1);
    const heightNM = Math.abs(end.y - start.y).toFixed(1);

    // Width label (centered at top)
    ctx.fillStyle = preview ? '#00ff00' : '#ffaa00';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`${widthNM} nm`, topLeft.x + widthPixels / 2, topLeft.y - 6);

    // Height label (centered at left)
    ctx.save();
    ctx.translate(topLeft.x - 6, topLeft.y + heightPixels / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(`${heightNM} nm`, 0, 0);
    ctx.restore();


    } else if (type === 'arc') {
        const radius = Math.sqrt(dx*dx + dy*dy);
        ctx.arc(startPx.x, startPx.y, radius * this.scale, 0, Math.PI); // simple half-arc
        ctx.stroke();
        ctx.fillText(`r=${radius.toFixed(1)} nm`, startPx.x + 5, startPx.y - 5);
    }
    ctx.setLineDash([]);
}

isInsideShape(shape, x, y) {
    const start = this.nmToCanvas(shape.start.x, shape.start.y);
    const end = this.nmToCanvas(shape.end.x, shape.end.y);
    const padding = 10;

    if (shape.type === 'rectangle') {
        const minX = Math.min(start.x, end.x) - padding;
        const maxX = Math.max(start.x, end.x) + padding;
        const minY = Math.min(start.y, end.y) - padding;
        const maxY = Math.max(start.y, end.y) + padding;
        return x >= minX && x <= maxX && y >= minY && y <= maxY;
    }

    if (shape.type === 'line' || shape.type === 'arc') {
        const dist = this.pointToLineDistance({ x, y }, start, end);
        return dist < padding;
    }

    if (shape.type === 'circle') {
    const center = this.nmToCanvas(shape.start.x, shape.start.y);
    const edge = this.nmToCanvas(shape.end.x, shape.end.y);
    const radius = Math.hypot(edge.x - center.x, edge.y - center.y); // pixel radius

    const dist = Math.hypot(x - center.x, y - center.y); // pixel distance from mouse to center

    return dist <= radius + padding; // allow clicking anywhere inside or slightly outside
}


    return false;
}

pointToLineDistance(p, a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const lenSq = dx * dx + dy * dy;

    if (lenSq === 0) return Math.hypot(p.x - a.x, p.y - a.y);

    const t = Math.max(0, Math.min(1, ((p.x - a.x) * dx + (p.y - a.y) * dy) / lenSq));
    const proj = { x: a.x + t * dx, y: a.y + t * dy };
    return Math.hypot(p.x - proj.x, p.y - proj.y);
}



updateHistoryPanel() {
    const list = document.getElementById('history-list');
    list.innerHTML = '';

    this.shapes.forEach((shape, index) => {
        const item = document.createElement('div');
        item.style.display = 'flex';
        item.style.justifyContent = 'space-between';
        item.style.alignItems = 'center';
        item.style.borderBottom = '1px solid #333';
        item.style.padding = '4px 0';

        const label = document.createElement('span');
        label.textContent = `${index + 1}: ${shape.type}`;

        const delBtn = document.createElement('button');
        delBtn.textContent = 'ðŸ—‘ï¸';
        delBtn.className = 'btn btn-danger';
        delBtn.style.fontSize = '12px';
        delBtn.onclick = () => {
            this.shapes.splice(index, 1);
            this.updateHistoryPanel();
            simulator.render(); // refresh display
        };

        item.appendChild(label);
        item.appendChild(delBtn);
        list.appendChild(item);
    });
}

            drawDistanceLine(point1, point2) {
                const canvas1 = this.nmToCanvas(point1.x, point1.y);
                const canvas2 = this.nmToCanvas(point2.x, point2.y);
                
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);

                this.ctx.beginPath();
                this.ctx.moveTo(canvas1.x, canvas1.y);
                this.ctx.lineTo(canvas2.x, canvas2.y);
                this.ctx.stroke();

                const distance = Math.sqrt(
                    Math.pow(point2.x - point1.x, 2) + 
                    Math.pow(point2.y - point1.y, 2)
                );

                const midX = (canvas1.x + canvas2.x) / 2;
                const midY = (canvas1.y + canvas2.y) / 2;

                this.ctx.fillStyle = '#ffff00';
                this.ctx.font = '12px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillRect(midX - 25, midY - 10, 50, 20);
                this.ctx.fillStyle = '#000000';
                this.ctx.fillText(distance.toFixed(1) + 'nm', midX, midY + 4);

                this.ctx.setLineDash([]);
            }

            setupMouseTracking() {
                this.canvas.addEventListener('mousemove', (event) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = event.clientX - rect.left;
                    const canvasY = event.clientY - rect.top;
                    
                    this.mousePos = this.canvasToNm(canvasX, canvasY);
                    
                    const coordsElement = document.getElementById('mouse-coords');
                    if (coordsElement) {
                        coordsElement.textContent = 
                            `${this.mousePos.x.toFixed(1)}, ${this.mousePos.y.toFixed(1)}`;
                    }

                    // Handle drag measuring
                    
if (this.isDragging) {
   if (this.selectedShapeIndex !== null) {
    const shape = this.shapes[this.selectedShapeIndex];

    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    const newCanvasStart = {
        x: mouseX - this.shapeDragOffset.x,
        y: mouseY - this.shapeDragOffset.y
    };

    const canvasStart = this.nmToCanvas(shape.start.x, shape.start.y);
    const canvasEnd = this.nmToCanvas(shape.end.x, shape.end.y);

    const offset = {
        x: newCanvasStart.x - canvasStart.x,
        y: newCanvasStart.y - canvasStart.y
    };

    // Apply offset to both start and end for all shapes
    const newCanvasEnd = {
        x: canvasEnd.x + offset.x,
        y: canvasEnd.y + offset.y
    };

    shape.start = this.canvasToNm(newCanvasStart.x, newCanvasStart.y);
    shape.end = this.canvasToNm(newCanvasEnd.x, newCanvasEnd.y);

    simulator.render();
}
 else if (this.dragStart) {
        //âœï¸ Drawing a new shape
        this.dragEnd = this.mousePos;
    }
}
                });

                this.canvas.addEventListener('mousedown', (event) => {
    const rect = this.canvas.getBoundingClientRect();
    const canvasX = event.clientX - rect.left;
    const canvasY = event.clientY - rect.top;

    // âœ… 1. SHIFT = draw a shape
    if (event.shiftKey) {
        const selector = document.getElementById('shape-selector');
        if (selector) this.drawingMode = selector.value;

        const pos = this.canvasToNm(canvasX, canvasY);
        this.dragStart = pos;
        this.dragEnd = null;
        this.isDragging = true;
        this.selectedShapeIndex = null;
        event.preventDefault();
        return;
    }

    // âœ… 2. CTRL = measure
    if (event.ctrlKey) {
        this.dragStart = this.canvasToNm(canvasX, canvasY);
        this.dragEnd = null;
        this.isDragging = true;
        this.selectedShapeIndex = null;
        event.preventDefault();
        return;
    }

    // âœ… 3. No modifier = maybe click shape to move
    for (let i = this.shapes.length - 1; i >= 0; i--) {
        const shape = this.shapes[i];
        if (this.isInsideShape(shape, canvasX, canvasY)) {
            this.selectedShapeIndex = i;
console.log("Selected shape type:", shape.type);


            const shapeCanvasStart = this.nmToCanvas(shape.start.x, shape.start.y);
            this.shapeDragOffset = {
                x: canvasX - shapeCanvasStart.x,
                y: canvasY - shapeCanvasStart.y
            };

            this.isDragging = true;
            return;
        }
    }

    // âœ… 4. If no shape was clicked, do nothing
    // Do NOT set selectedShapeIndex = null here â€” let it stay unchanged
});




this.canvas.addEventListener('mouseup', (event) => {
    const rect = this.canvas.getBoundingClientRect();
    const canvasX = event.clientX - rect.left;
    const canvasY = event.clientY - rect.top;

    // âœ… If we're drawing a new shape
    if (event.shiftKey && this.dragStart && this.dragEnd && this.selectedShapeIndex === null) {
        this.shapes.push({
            type: this.drawingMode,
            start: { ...this.dragStart },
            end: { ...this.dragEnd },
            name: ''
        });
        this.updateHistoryPanel?.();
    }

    // âœ… Reset all state AFTER dragging finishes
    this.isDragging = false;
    this.dragStart = null;
    this.dragEnd = null;
    this.selectedShapeIndex = null;

    simulator.render();
});




                this.canvas.addEventListener('click', (event) => {
                    if (!event.ctrlKey) {
                        const rect = this.canvas.getBoundingClientRect();
                        const canvasX = event.clientX - rect.left;
                        const canvasY = event.clientY - rect.top;
                        
                        const nmPos = this.canvasToNm(canvasX, canvasY);
                        this.handleGridClick(nmPos);
                    }
                });
            }

            handleGridClick(nmPos) {
                this.selectedPoints.push(nmPos);
                
                if (this.selectedPoints.length > 2) {
                    this.selectedPoints = [nmPos];
                }
                
                if (this.selectedPoints.length === 2) {
                    const distance = Math.sqrt(
                        Math.pow(this.selectedPoints[1].x - this.selectedPoints[0].x, 2) + 
                        Math.pow(this.selectedPoints[1].y - this.selectedPoints[0].y, 2)
                    );
                    
                    const distanceElement = document.getElementById('selected-distance');
                    if (distanceElement) {
                        distanceElement.textContent = distance.toFixed(1) + ' nm';
                    }
                } else {
                    const distanceElement = document.getElementById('selected-distance');
                    if (distanceElement) {
                        distanceElement.textContent = '---';
                    }
                }
            }

            getSelectedPoints() {
                return [...this.selectedPoints];
            }

            clearSelection() {
                this.selectedPoints = [];
                const distanceElement = document.getElementById('selected-distance');
                if (distanceElement) {
                    distanceElement.textContent = '---';
                }
            }
        }

        /**
         * Aircraft management and rendering
         */
        class Aircraft {
            constructor(id, position, heading, speed, color, isLead = false) {
                this.id = id;
                this.position = { ...position };
                this.heading = heading;
                this.initialHeading = heading; // Store initial heading for turn calculations
                this.speed = speed;
                this.color = color;
                this.isLead = isLead;
                
                this.formationOffset = null;
                this.followLead = true;
                this.manualOverride = false;
                this.turnCommand = 0; // Degrees to turn on next advance
		this.boundTo = null;  // NEW: Name of the aircraft it is following
		this.lastTurnExecuted = 0;  // âœ… Keep track of the actual turn just executed


                
                this.positionHistory = [{ ...position }];
                this.headingHistory = [heading];
                
                this.size = isLead ? 12 : 10;
                this.selected = false;
                this.active = true;
            }

            update(physics, leadAircraft = null, simulator = null, stepDuration = 0.5) {
    // âœ³ï¸ 1. Handle aircraft that are BOUND to another aircraft
    if (this.boundTo && this.boundTo !== this.id) {
        const boundAircraft = simulator.aircraft.get(this.boundTo);
        if (boundAircraft) {
            const mirroredTurn = boundAircraft.lastTurnExecuted;
            const mirroredSpeed = boundAircraft.speed;

            const newHeading = this.normalizeAngle(this.heading + mirroredTurn);

            const turnPath = physics.calculateFixedDistanceTurnPath(
                this.position,
                this.heading,
                newHeading,
                mirroredSpeed * stepDuration
            );

            turnPath.waypoints.forEach(wp => this.positionHistory.push({ ...wp }));
		this.position = turnPath.finalPosition;
		this.heading = turnPath.actualHeading;
		this.headingHistory.push(this.heading);
		this.lastTurnExecuted = mirroredTurn;

            return; // Done!
        }
    }

    // âœ³ï¸ 2. Manual override (formation aircraft)
    if (!this.isLead && this.manualOverride) {
        this.lastTurnExecuted = this.turnCommand;
	const newHeading = this.normalizeAngle(this.heading + this.turnCommand);
        const turnPath = physics.calculateFixedDistanceTurnPath(
            this.position,
            this.heading,
            newHeading,
            this.speed * stepDuration
        );
        turnPath.waypoints.forEach(wp => this.positionHistory.push({ ...wp }));
        this.position = turnPath.finalPosition;
        this.heading = turnPath.actualHeading;
        this.headingHistory.push(this.heading);
        this.turnCommand = 0;
        return;
    }

    // âœ³ï¸ 3. Follower using formation logic
    if (!this.isLead && leadAircraft) {
        this.turnCommand = leadAircraft.turnCommand;
        this.speed = leadAircraft.speed;
	this.lastTurnExecuted = this.turnCommand;
        const newHeading = this.normalizeAngle(this.heading + this.turnCommand);
        const turnPath = physics.calculateFixedDistanceTurnPath(
            this.position,
            this.heading,
            newHeading,
            this.speed * stepDuration
        );
        turnPath.waypoints.forEach(wp => this.positionHistory.push({ ...wp }));
        this.position = turnPath.finalPosition;
        this.heading = turnPath.actualHeading;
        this.headingHistory.push(this.heading);
        this.turnCommand = 0;
        return;
    }

    // âœ³ï¸ 4. Lead aircraft
	this.lastTurnExecuted = this.turnCommand;   
	const newHeading = this.normalizeAngle(this.heading + this.turnCommand);	const turnPath = physics.calculateFixedDistanceTurnPath(
        this.position,
        this.heading,
        newHeading,
        this.speed * stepDuration
    );
    turnPath.waypoints.forEach(wp => this.positionHistory.push({ ...wp }));
    this.position = turnPath.finalPosition;
    this.heading = turnPath.actualHeading;
    this.headingHistory.push(this.heading);
    this.turnCommand = 0;
}


            updateFormationPosition(physics, leadAircraft) {
                if (!this.formationOffset) {
                    return;
                }

                // Follow lead aircraft's movement
                this.turnCommand = leadAircraft.turnCommand;
                this.updateIndependentPosition(physics);
                
                // Then adjust to maintain formation position
                const formationPos = physics.calculateFormationPosition(
                    leadAircraft.position,
                    leadAircraft.heading,
                    this.formationOffset.azimuthDistance || 0,
                    this.formationOffset.azimuthDirection || 'positive',
                    this.formationOffset.depthDistance || 0,
                    this.formationOffset.depthDirection || 'positive'
                );

                this.position = formationPos;
                this.heading = leadAircraft.heading;
            }

            updateIndependentPosition(physics) {
                // Calculate new heading based on turn command
                const newHeading = this.normalizeAngle(this.heading + this.turnCommand);
                
                // Use fixed 5nm movement with turn path
                const turnPath = physics.calculateFixedDistanceTurnPath(
                    this.position,
                    this.heading,
                    newHeading,
                    2.5 // Always move exactly 5nm
                );
                
                // Add waypoints to position history
                turnPath.waypoints.forEach(waypoint => {
                    this.positionHistory.push({ ...waypoint });
                });
                
                // Update final position and heading
                this.position = turnPath.finalPosition;
                this.heading = turnPath.actualHeading;
                this.headingHistory.push(this.heading);
                
                // Reset turn command after execution
                this.turnCommand = 0;
            }

            normalizeAngle(angle) {
                while (angle < 0) angle += 360;
                while (angle >= 360) angle -= 360;
                return angle;
            }

            setFormationOffset(azimuthDistance, azimuthDirection, depthDistance, depthDirection) {
                this.formationOffset = {
                    azimuthDistance: azimuthDistance || 0,
                    azimuthDirection: azimuthDirection || 'positive',
                    depthDistance: depthDistance || 0,
                    depthDirection: depthDirection || 'positive'
                };
            }

            render(ctx, grid, showLabels = false) {
                const canvasPos = grid.nmToCanvas(this.position.x, this.position.y);
                
                this.renderTrail(ctx, grid);
                this.renderAircraftSymbol(ctx, canvasPos);
                
                // Only show labels on hover
                if (showLabels) {
                    this.renderLabel(ctx, canvasPos);
                }
            }

            renderTrail(ctx, grid) {
                if (this.positionHistory.length < 2) return;

                ctx.strokeStyle = this.color + '80';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);

                ctx.beginPath();
                const startPos = grid.nmToCanvas(
                    this.positionHistory[0].x, 
                    this.positionHistory[0].y
                );
                ctx.moveTo(startPos.x, startPos.y);

                for (let i = 1; i < this.positionHistory.length; i++) {
                    const pos = grid.nmToCanvas(
                        this.positionHistory[i].x, 
                        this.positionHistory[i].y
                    );
                    ctx.lineTo(pos.x, pos.y);
                }

                ctx.stroke();
                ctx.setLineDash([]);
            }

            renderAircraftSymbol(ctx, canvasPos) {
                // Convert heading to canvas rotation (0Â° = North, 90Â° = East, etc.)
                // Canvas rotation: 0 = right, Ï€/2 = down, Ï€ = left, 3Ï€/2 = up
                // Aviation heading: 0Â° = North, 90Â° = East, 180Â° = South, 270Â° = West
                const headingRad = this.heading * Math.PI / 180;
                
                ctx.save();
                ctx.translate(canvasPos.x, canvasPos.y);
                ctx.rotate((-this.heading) * Math.PI / 180);


                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.selected ? '#ffffff' : '#000000';
                ctx.lineWidth = this.selected ? 3 : 1;

                // Draw arrow shape pointing right (which will be rotated to correct heading)
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size * 0.6, -this.size * 0.4);
                ctx.lineTo(-this.size * 0.4, -this.size * 0.2);
                ctx.lineTo(-this.size * 0.8, 0);
                ctx.lineTo(-this.size * 0.4, this.size * 0.2);
                ctx.lineTo(-this.size * 0.6, this.size * 0.4);
                ctx.closePath();

                ctx.fill();
                ctx.stroke();

                // Lead aircraft indicator
                if (this.isLead) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 4, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                ctx.restore();
            }

            renderLabel(ctx, canvasPos) {
                ctx.fillStyle = this.color;
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                
                const labelText = `${this.id}`;
                const speedText = `${this.speed.toFixed(1)}nm/min`;
                const headingText = `${this.heading.toString().padStart(3, '0')}Â°`;
                
                const labelWidth = Math.max(
                    ctx.measureText(labelText).width,
                    ctx.measureText(speedText).width,
                    ctx.measureText(headingText).width
                );
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvasPos.x + 15, canvasPos.y - 10, labelWidth + 10, 55);
                
                ctx.fillStyle = this.color;
                ctx.fillText(labelText, canvasPos.x + 20, canvasPos.y + 5);
                ctx.fillStyle = '#cccccc';
                ctx.font = '10px monospace';
                ctx.fillText(speedText, canvasPos.x + 20, canvasPos.y + 20);
                ctx.fillText(headingText, canvasPos.x + 20, canvasPos.y + 35);
            }

            getDistanceTo(otherAircraft) {
                const dx = otherAircraft.position.x - this.position.x;
                const dy = otherAircraft.position.y - this.position.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            clone() {
                const clone = new Aircraft(
                    this.id,
                    { ...this.position },
                    this.heading,
                    this.speed,
                    this.color,
                    this.isLead
                );
                
                clone.formationOffset = this.formationOffset ? { ...this.formationOffset } : null;
                clone.followLead = this.followLead;
                clone.manualOverride = this.manualOverride;
                clone.positionHistory = this.positionHistory.map(pos => ({ ...pos }));
                clone.headingHistory = [...this.headingHistory];
                clone.size = this.size;
                clone.selected = this.selected;
                clone.active = this.active;
                
                return clone;
            }

            reset() {
                if (this.positionHistory.length > 0) {
                    this.position = { ...this.positionHistory[0] };
                }
                if (this.headingHistory.length > 0) {
                    this.heading = this.headingHistory[0];
                }
                this.positionHistory = [{ ...this.position }];
                this.headingHistory = [this.heading];
                this.manualOverride = false;
                this.selected = false;
            }
        }

        /**
         * Main tactical aircraft simulator
         */
        class TacticalSimulator {
	
	updateSeparationDistance(separation) {
    	const half = separation / 2;

    	const blue1 = this.aircraft.get('Blue 1');
    	const red1 = this.aircraft.get('Red 1');

    	if (blue1 && red1) {
        	blue1.position.x = -half;
        	red1.position.x = half;

        // Reset position history to new origin
        	blue1.positionHistory = [{ ...blue1.position }];
        	red1.positionHistory = [{ ...red1.position }];

        // Recalculate red formation aircraft
        this.repositionRedFormation();
    }

    // Optional: Save state and re-render
    	this.saveState();
    	this.render();
    	this.updateUI();
}
            
	constructor() {
                this.canvas = document.getElementById('tactical-grid');
                this.ctx = this.canvas.getContext('2d');
                this.grid = new TacticalGrid(this.canvas, this.ctx);
                this.physics = new PhysicsEngine();
                
                this.aircraft = new Map();
                this.simulationTime = 0;
                this.simulationStep = 0;
		this.timeStepSeconds = 30;
                this.simulationHistory = [];
                this.isRunning = false;
                this.hoveredAircraft = null;
                
                this.selectedAircraftSide = null;
                
                this.initializeDefaultAircraft();
                this.setupEventListeners();
                this.setupModalEventListeners();
                this.setupHoverDetection();
                
                this.render();
                this.updateUI();
            }

           initializeDefaultAircraft() {
    const initialSeparation = 65; // default separation at startup
    const half = initialSeparation / 2;

    const blue1 = new Aircraft(
        'Blue 1',
        { x: -half, y: 0 },
        0,  // Blue faces east
        10,
        '#0066cc',
        true
    );

    const red1 = new Aircraft(
        'Red 1',
        { x: half, y: 0 },
        180,  // Red faces west
        10,
        '#cc3300',
        true
    );

    this.aircraft.set('Blue 1', blue1);
    this.aircraft.set('Red 1', red1);

    this.saveState();
}


            // Calculate formation center for red forces based on blue formation
            calculateRedFormationCenter() {
                const blueAircraft = Array.from(this.aircraft.values()).filter(a => a.color === '#0066cc');
                if (blueAircraft.length === 0) return { x: 32.5, y: 0 };

                // Find the center of blue formation
                let sumX = 0, sumY = 0;
                blueAircraft.forEach(aircraft => {
                    sumX += aircraft.position.x;
                    sumY += aircraft.position.y;
                });

                const blueCenterX = sumX / blueAircraft.length;
                const blueCenterY = sumY / blueAircraft.length;

                // Red should be centered on blue's Y axis, maintaining 65nm separation
                const separation = 65;
                return { x: blueCenterX + separation, y: blueCenterY };
            }

            repositionRedFormation() {
                const redCenter = this.calculateRedFormationCenter();
                const red1 = this.aircraft.get('Red 1');
                if (red1) {
                    red1.position.y = redCenter.y;
                }

                // Update all red formation aircraft relative to new red1 position
                this.aircraft.forEach(aircraft => {
                    if (!aircraft.isLead && aircraft.color === '#cc3300') {
                        const leadAircraft = this.aircraft.get('Red 1');
                        if (leadAircraft && aircraft.formationOffset) {
                            const formationPos = this.physics.calculateFormationPosition(
                                leadAircraft.position,
                                leadAircraft.heading,
                                aircraft.formationOffset.azimuthDistance || 0,
                                aircraft.formationOffset.azimuthDirection || 'positive',
                                aircraft.formationOffset.depthDistance || 0,
                                aircraft.formationOffset.depthDirection || 'positive'
                            );
                            aircraft.position = formationPos;
                        }
                    }
                });
            }

            setupEventListeners() {
		
		document.getElementById('separation-slider').addEventListener('input', (e) => {
    		const value = parseInt(e.target.value);
    		document.getElementById('separation-label').textContent = `${value} nm`;
    		this.updateSeparationDistance(value);
		});

		document.getElementById('canvas-rotation-slider').addEventListener('input', (e) => {
    		const degrees = parseInt(e.target.value);

    		// 1. Apply rotation to the grid
    		this.grid.setRotation(degrees);

    		// 2. Update the label next to the slider
    		document.getElementById('rotation-angle-label').textContent = `${degrees}Â°`;

    		// 3. Update the compass needle (optional)
    		if (typeof this.updateCompass === 'function') {
       		 this.updateCompass();
   		 }

    		// 4. Redraw the scene
   		 this.render();
		});

document.getElementById('time-step-selector').addEventListener('change', (e) => {
    this.timeStepSeconds = parseInt(e.target.value);
});

document.getElementById('toggle-history-btn').addEventListener('click', () => {
    const history = document.getElementById('drawing-history');
    const button = document.getElementById('toggle-history-btn');
    const isVisible = history.style.display === 'block';

    history.style.display = isVisible ? 'none' : 'block';
    button.textContent = isVisible ? 'Show History' : 'Hide History';
});

                document.getElementById('advance-btn').addEventListener('click', () => {
                    this.advanceSimulation();
                });
                
                document.getElementById('undo-btn').addEventListener('click', () => {
                    this.undoLastStep();
                });
                
                document.getElementById('reset-btn').addEventListener('click', () => {
                    this.resetSimulation();
                });

                document.getElementById('clear-trails-btn').addEventListener('click', () => {
                    this.clearTrails();
                });

                document.getElementById('reposition-btn').addEventListener('click', () => {
                    this.repositionAllForces();
                });

                document.getElementById('blue1-turn').addEventListener('change', (e) => {
                    this.setAircraftTurnCommand('Blue 1', parseInt(e.target.value));
                });
                
                document.getElementById('blue1-speed').addEventListener('change', (e) => {
                    this.updateAircraftSpeed('Blue 1', parseFloat(e.target.value));
                });
                
                document.getElementById('red1-turn').addEventListener('change', (e) => {
                    this.setAircraftTurnCommand('Red 1', parseInt(e.target.value));
                });
                
                document.getElementById('red1-speed').addEventListener('change', (e) => {
                    this.updateAircraftSpeed('Red 1', parseFloat(e.target.value));
                });

                document.getElementById('add-blue-aircraft').addEventListener('click', () => {
                    this.showAddAircraftModal('blue');
                });
                
                document.getElementById('add-red-aircraft').addEventListener('click', () => {
                    this.showAddAircraftModal('red');
                });

                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.advanceSimulation();
                            break;
                        case 'z':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                this.undoLastStep();
                            }
                            break;
                        case 'r':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                this.resetSimulation();
                            }
                            break;
                    }
document.getElementById('shape-selector').addEventListener('change', (e) => {
    this.grid.drawingMode = e.target.value;
});
document.getElementById('save-shapes-btn').addEventListener('click', () => {
    const blob = new Blob([JSON.stringify(this.grid.shapes)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'shapes.json';
    a.click();
    URL.revokeObjectURL(url);
});
document.getElementById('load-shapes-btn').addEventListener('click', () => {
    document.getElementById('load-shapes-input').click();
});
document.getElementById('load-shapes-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        try {
            const shapes = JSON.parse(reader.result);
            if (Array.isArray(shapes)) {
                this.grid.shapes = shapes;
                this.render();
            } else {
                alert('Invalid shape file');
            }
        } catch (err) {
            alert('Failed to load shapes');
        }
    };
    reader.readAsText(file);
});

                });
            }

            setupModalEventListeners() {
                // Modal position control checkboxes
                document.getElementById('use-azimuth').addEventListener('change', (e) => {
                    const azimuthInputs = [
                        document.getElementById('azimuth-distance'),
                        document.getElementById('azimuth-direction')
                    ];
                    azimuthInputs.forEach(input => input.disabled = !e.target.checked);
                });

                document.getElementById('use-depth').addEventListener('change', (e) => {
                    const depthInputs = [
                        document.getElementById('depth-distance'),
                        document.getElementById('depth-direction')
                    ];
                    depthInputs.forEach(input => input.disabled = !e.target.checked);
                });

                document.getElementById('confirm-add-aircraft').addEventListener('click', () => {
                    this.confirmAddAircraft();
                });
                
                document.getElementById('cancel-add-aircraft').addEventListener('click', () => {
                    this.hideAddAircraftModal();
                });
            }

            advanceSimulation() {
    this.aircraft.forEach(aircraft => {
        // 1. Find the lead aircraft (if applicable)
        const leadAircraft = aircraft.isLead ? null : this.getLeadAircraft(aircraft);

        // 2. Let the aircraft update its position/heading based on turn command
        const stepDurationMinutes = this.timeStepSeconds / 60;
	aircraft.update(this.physics, leadAircraft, this, stepDurationMinutes);


        // âœ… 3. After that turn is completed, reset the dropdown to "Straight"

        // We build the ID of the dropdown â€” it's like "blue1-turn", "red1-turn"
        const turnSelectId = `${aircraft.id.toLowerCase().replace(/\s+/g, '')}-turn`;

        // Try to get that dropdown from the page
        const turnSelect = document.getElementById(turnSelectId);

        // If the dropdown exists, reset its selected value to "0"
        if (turnSelect) {
            turnSelect.value = "0";
        }
    });

    // Advance time by 30 seconds (0.5 min)
    this.simulationTime += this.timeStepSeconds / 60;
    this.simulationStep += 1;

    // Save the new state, re-render everything
    this.saveState();
    this.render();
    this.updateUI();
}



            undoLastStep() {
                if (this.simulationHistory.length > 1) {
                    this.simulationHistory.pop();
                    const previousState = this.simulationHistory[this.simulationHistory.length - 1];
                    this.restoreState(previousState);
                    this.render();
                    this.updateUI();
                }
            }

            resetSimulation() {
                if (this.simulationHistory.length > 0) {
                    const initialState = this.simulationHistory[0];
                    this.restoreState(initialState);
                    this.simulationHistory = [initialState];
                    this.render();
                    this.updateUI();
                }
            }

            clearTrails() {
                this.aircraft.forEach(aircraft => {
                    aircraft.positionHistory = [{ ...aircraft.position }];
                    aircraft.headingHistory = [aircraft.heading];
                });
                this.render();
            }

            repositionAllForces() {
                // Calculate center of all blue aircraft
                const blueAircraft = Array.from(this.aircraft.values()).filter(a => a.color === '#0066cc');
                const redAircraft = Array.from(this.aircraft.values()).filter(a => a.color === '#cc3300');
                
                if (blueAircraft.length === 0 || redAircraft.length === 0) return;

                // Find blue formation center
                let blueSumX = 0, blueSumY = 0;
                blueAircraft.forEach(aircraft => {
                    blueSumX += aircraft.position.x;
                    blueSumY += aircraft.position.y;
                });
                const blueCenterY = blueSumY / blueAircraft.length;

                // Find red formation center
                let redSumX = 0, redSumY = 0;
                redAircraft.forEach(aircraft => {
                    redSumX += aircraft.position.x;
                    redSumY += aircraft.position.y;
                });
                const redCenterX = redSumX / redAircraft.length;
                const redCenterY = redSumY / redAircraft.length;

                // Move all red aircraft to center on blue's Y axis
                const yOffset = blueCenterY - redCenterY;
                redAircraft.forEach(aircraft => {
                    aircraft.position.y += yOffset;
                    // Reset position history to current position
                    aircraft.positionHistory = [{ ...aircraft.position }];
                });

                this.render();
            }

            saveState() {
                const state = {
                    aircraft: new Map(),
                    simulationTime: this.simulationTime,
                    simulationStep: this.simulationStep
                };
                
                this.aircraft.forEach((aircraft, id) => {
                    state.aircraft.set(id, aircraft.clone());
                });
                
                this.simulationHistory.push(state);
                
                if (this.simulationHistory.length > 100) {
                    this.simulationHistory.shift();
                }
            }

            restoreState(state) {
                this.aircraft.clear();
                state.aircraft.forEach((aircraft, id) => {
                    this.aircraft.set(id, aircraft.clone());
                });
                
                this.simulationTime = state.simulationTime;
                this.simulationStep = state.simulationStep;
                
                const blue1 = this.aircraft.get('Blue 1');
                const red1 = this.aircraft.get('Red 1');
                
                if (blue1) {
                    // document.getElementById('blue1-heading').value = blue1.heading;
                    document.getElementById('blue1-speed').value = blue1.speed;
                }
                
                if (red1) {
                    // document.getElementById('red1-heading').value = red1.heading;
                    document.getElementById('red1-speed').value = red1.speed;
                }
            }

            setAircraftTurnCommand(aircraftId, turnDegrees) {
                const aircraft = this.aircraft.get(aircraftId);
                if (aircraft) {
                    aircraft.turnCommand = turnDegrees;
                    // Reset turn selector to default after setting command
                    const turnSelect = document.getElementById(`${aircraftId.toLowerCase().replace(' ', '')}-turn`);
                    
                }
            }

            updateAircraftSpeed(aircraftId, speed) {
                const aircraft = this.aircraft.get(aircraftId);
                if (aircraft) {
                    aircraft.speed = Math.max(0.1, speed);
                    this.render();
                }
            }

            showAddAircraftModal(side) {
                this.selectedAircraftSide = side;
                const modal = document.getElementById('add-aircraft-modal');
                const aircraftId = document.getElementById('new-aircraft-id');
                
                const leadId = side === 'blue' ? 'Blue 1' : 'Red 1';
                const existingCount = Array.from(this.aircraft.keys())
                    .filter(id => id.startsWith(side === 'blue' ? 'Blue' : 'Red')).length;
                aircraftId.value = `${side === 'blue' ? 'Blue' : 'Red'} ${existingCount + 1}`;
                
                // Reset modal state
                document.getElementById('use-azimuth').checked = false;
                document.getElementById('use-depth').checked = false;
                document.getElementById('azimuth-distance').disabled = true;
                document.getElementById('azimuth-direction').disabled = true;
                document.getElementById('depth-distance').disabled = true;
                document.getElementById('depth-direction').disabled = true;
                
                modal.style.display = 'block';
            }

            hideAddAircraftModal() {
                document.getElementById('add-aircraft-modal').style.display = 'none';
                this.selectedAircraftSide = null;
            }

            confirmAddAircraft() {
                const aircraftId = document.getElementById('new-aircraft-id').value;
                const useAzimuth = document.getElementById('use-azimuth').checked;
                const useDepth = document.getElementById('use-depth').checked;
                
                if (!aircraftId || this.aircraft.has(aircraftId)) {
                    alert('Please enter a unique aircraft ID');
                    return;
                }

                if (!useAzimuth && !useDepth) {
                    alert('Please select at least one position type (Azimuth or Depth)');
                    return;
                }
                
                const leadId = this.selectedAircraftSide === 'blue' ? 'Blue 1' : 'Red 1';
                const leadAircraft = this.aircraft.get(leadId);
                
                if (!leadAircraft) {
                    alert('Lead aircraft not found');
                    return;
                }

                let azimuthDistance = 0, azimuthDirection = 'positive';
                let depthDistance = 0, depthDirection = 'positive';

                if (useAzimuth) {
                    azimuthDistance = parseFloat(document.getElementById('azimuth-distance').value);
                    azimuthDirection = document.getElementById('azimuth-direction').value;
                }

                if (useDepth) {
                    depthDistance = parseFloat(document.getElementById('depth-distance').value);
                    depthDirection = document.getElementById('depth-direction').value;
                }
                
                const formationPos = this.physics.calculateFormationPosition(
                    leadAircraft.position,
                    leadAircraft.heading,
                    azimuthDistance,
                    azimuthDirection,
                    depthDistance,
                    depthDirection
                );
                
                const newAircraft = new Aircraft(
                    aircraftId,
                    formationPos,
                    leadAircraft.heading,
                    leadAircraft.speed,
                    this.selectedAircraftSide === 'blue' ? '#0066cc' : '#cc3300',
                    false
                );
                
                newAircraft.setFormationOffset(azimuthDistance, azimuthDirection, depthDistance, depthDirection);
                
                this.aircraft.set(aircraftId, newAircraft);
                
                // Always reposition red formation to center on blue axis when any aircraft is added
                this.repositionRedFormation();
                
                this.updateFormationList();
                this.render();
                this.hideAddAircraftModal();
            }

            removeAircraft(aircraftId) {
                const aircraft = this.aircraft.get(aircraftId);
                if (aircraft && !aircraft.isLead) {
                    this.aircraft.delete(aircraftId);
                    
                    // If removing blue aircraft, reposition red formation
                    if (aircraft.color === '#0066cc') {
                        this.repositionRedFormation();
                    }
                    
                    this.updateFormationList();
                    this.render();
                }
            }

            getLeadAircraft(aircraft) {
                const leadId = aircraft.color === '#0066cc' ? 'Blue 1' : 'Red 1';
                return this.aircraft.get(leadId);
            }

            toggleManualOverride(aircraftId) {
                const aircraft = this.aircraft.get(aircraftId);
                if (aircraft && !aircraft.isLead) {
                    aircraft.manualOverride = !aircraft.manualOverride;
                    
                    // Toggle manual controls visibility
                    const manualControls = document.getElementById(`manual-controls-${aircraftId}`);
                    if (manualControls) {
                        if (aircraft.manualOverride) {
                            manualControls.classList.add('active');
                        } else {
                            manualControls.classList.remove('active');
                        }
                    }
                    
                    this.updateFormationList();
                }
            }

            updateFormationList() {
                const blueList = document.getElementById('blue-formation-list');
                const redList = document.getElementById('red-formation-list');
                
                blueList.innerHTML = '';
                redList.innerHTML = '';
                
                this.aircraft.forEach(aircraft => {
                    if (!aircraft.isLead) {
                        const element = this.createFormationAircraftElement(aircraft);
                        if (aircraft.color === '#0066cc') {
                            blueList.appendChild(element);
                        } else {
                            redList.appendChild(element);
                        }
                    }
                });
            }

            createFormationAircraftElement(aircraft) {
                const div = document.createElement('div');
                div.className = 'formation-aircraft';
                
                const header = document.createElement('div');
                header.className = 'formation-aircraft-header';
                
                const name = document.createElement('span');
                name.className = 'formation-aircraft-name';
                name.textContent = aircraft.id;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-aircraft';
                removeBtn.textContent = 'Ã—';
                removeBtn.addEventListener('click', () => {
                    this.removeAircraft(aircraft.id);

                });
                
                header.appendChild(name);
                header.appendChild(removeBtn);
                div.appendChild(header);

                
                if (aircraft.formationOffset) {
                    const params = document.createElement('div');
                    params.className = 'formation-params';
                    let paramText = '';
                    
                    if (aircraft.formationOffset.azimuthDistance > 0) {
                        paramText += `Azimuth: ${aircraft.formationOffset.azimuthDistance}nm ${aircraft.formationOffset.azimuthDirection}`;
                    }
                    
                    if (aircraft.formationOffset.depthDistance > 0) {
                        if (paramText) paramText += ', ';
                        paramText += `Depth: ${aircraft.formationOffset.depthDistance}nm ${aircraft.formationOffset.depthDirection}`;
                    }
                    
                    params.innerHTML = `<small>${paramText}</small>`;
                    div.appendChild(params);
                }
                
                const overrideDiv = document.createElement('div');
                const overrideCheckbox = document.createElement('input');
                overrideCheckbox.type = 'checkbox';
                overrideCheckbox.className = 'override-checkbox';
                overrideCheckbox.checked = aircraft.manualOverride;
                overrideCheckbox.addEventListener('change', () => {
                    this.toggleManualOverride(aircraft.id);
                });
                
                const overrideLabel = document.createElement('label');
                overrideLabel.innerHTML = 'Manual Override';
                overrideLabel.prepend(overrideCheckbox);
                
                overrideDiv.appendChild(overrideLabel);
                div.appendChild(overrideDiv);
                
                // Manual controls (show when override is enabled)
                const manualControls = document.createElement('div');
                manualControls.className = `manual-controls ${aircraft.manualOverride ? 'active' : ''}`;
                manualControls.id = `manual-controls-${aircraft.id}`;
                
// BIND TO: DROPDOWN
const bindRow = document.createElement('div');
bindRow.className = 'manual-control-row';
bindRow.innerHTML = `
    <label>Bind to:</label>
    <select id="bind-${aircraft.id}">
        <option value="">None</option>
        ${Array.from(this.aircraft.values())
            .filter(other => other.id !== aircraft.id)
            .map(other => `<option value="${other.id}" ${aircraft.boundTo === other.id ? 'selected' : ''}>${other.id}</option>`)
            .join('')}
    </select>
`;
div.appendChild(bindRow);  // This adds it to the panel

                // Turn control
                const turnRow = document.createElement('div');
                turnRow.className = 'manual-control-row';
                turnRow.innerHTML = `
                    <label>Turn:</label>
                    <select id="turn-${aircraft.id}">
                        <option value="0">Straight</option>
                        <option value="45">45Â° Left</option>
                        <option value="-45">45Â° Right</option>
                        <option value="90">90Â° Left</option>
                        <option value="-90">90Â° Right</option>
			<option value="135">135Â° Left</option>
			<option value="-135">135Â° Right</option>
                        <option value="180">180Â° Left</option>
			<option value="-180">180Â° Right</option>
                    </select>
                `;
                
                // Speed control
                const speedRow = document.createElement('div');
                speedRow.className = 'manual-control-row';
                speedRow.innerHTML = `
                    <label>Speed:</label>
                    <input type="number" id="speed-${aircraft.id}" value="${aircraft.speed}" min="1" max="50" step="0.1">
                    <span style="font-size: 0.7em;">nm/min</span>
                `;
                
                manualControls.appendChild(turnRow);
                manualControls.appendChild(speedRow);
                div.appendChild(manualControls);
                
                // Add event listeners for manual controls
                setTimeout(() => {
                    const turnSelect = document.getElementById(`turn-${aircraft.id}`);
                    const speedInput = document.getElementById(`speed-${aircraft.id}`);
const bindSelect = document.getElementById(`bind-${aircraft.id}`);
if (bindSelect) {
    bindSelect.addEventListener('change', (e) => {
        aircraft.boundTo = e.target.value || null;
    });
}

                    
                    if (turnSelect) {
                        turnSelect.addEventListener('change', (e) => {
                            this.setAircraftTurnCommand(aircraft.id, parseInt(e.target.value));
                        });
                    }
                    
                    if (speedInput) {
                        speedInput.addEventListener('change', (e) => {
                            this.updateAircraftSpeed(aircraft.id, parseFloat(e.target.value));
                        });
                    }
                }, 100);
                
                return div;
            }

            setupHoverDetection() {
                this.canvas.addEventListener('mousemove', (event) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = event.clientX - rect.left;
                    const canvasY = event.clientY - rect.top;
                    const nmPos = this.grid.canvasToNm(canvasX, canvasY);
                    
                    let foundHover = false;
                    this.aircraft.forEach(aircraft => {
                        const distance = Math.sqrt(
                            Math.pow(aircraft.position.x - nmPos.x, 2) + 
                            Math.pow(aircraft.position.y - nmPos.y, 2)
                        );
                        
                        if (distance < 2) {
                            this.hoveredAircraft = aircraft.id;
                            foundHover = true;
                        }
                    });
                    
                    if (!foundHover) {
                        this.hoveredAircraft = null;
                    }
                    
                    this.render();
                });
            }

          render() {
    this.grid.render(); // grid already applies rotation

    this.ctx.save();  // âœ… Start a new transform

    // âœ… Rotate canvas before drawing aircraft
    const degrees = this.grid.rotationDegrees;
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;

    this.ctx.translate(centerX, centerY);
    this.ctx.rotate(-degrees * Math.PI / 180);
    this.ctx.translate(-centerX, -centerY);

    // Now draw aircraft in the rotated space
    this.aircraft.forEach(aircraft => {
        const showLabels = this.hoveredAircraft === aircraft.id;
        aircraft.render(this.ctx, this.grid, showLabels);
    });

    this.ctx.restore(); // ðŸ§¼ Clean up
}


            updateUI() {
    const totalSeconds = Math.round(this.simulationTime * 60);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;

    const timeDisplay = `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
    const stepText = `(${this.timeStepSeconds}s steps)`;

    // Replace entire innerHTML of the time labelâ€™s parent span
    const simTimeContainer = document.querySelector('#sim-time').parentElement;
    if (simTimeContainer) {
        simTimeContainer.innerHTML = `Time: <span id="sim-time">${timeDisplay}</span> ${stepText}`;
    }

    // Step count
    document.getElementById('sim-step').textContent = this.simulationStep;

    this.updateDistanceDisplays();
    this.updateFormationList();
}


            updateDistanceDisplays() {
                const blueDistances = document.getElementById('blue-distances');
                const redDistances = document.getElementById('red-distances');
                
                blueDistances.innerHTML = '';
                redDistances.innerHTML = '';
                
                const blueAircraft = Array.from(this.aircraft.values()).filter(a => a.color === '#0066cc');
                const redAircraft = Array.from(this.aircraft.values()).filter(a => a.color === '#cc3300');
                
                blueAircraft.forEach(blueAC => {
                    redAircraft.forEach(redAC => {
                        const distance = blueAC.getDistanceTo(redAC);
                        const distanceItem = document.createElement('div');
                        distanceItem.className = 'distance-item';
                        distanceItem.innerHTML = `
                            <span>${blueAC.id} â†’ ${redAC.id}</span>
                            <span class="distance-value">${distance.toFixed(1)} nm</span>
                        `;
                        blueDistances.appendChild(distanceItem);
                    });
                });
                
                redAircraft.forEach(redAC => {
                    blueAircraft.forEach(blueAC => {
                        const distance = redAC.getDistanceTo(blueAC);
                        const distanceItem = document.createElement('div');
                        distanceItem.className = 'distance-item';
                        distanceItem.innerHTML = `
                            <span>${redAC.id} â†’ ${blueAC.id}</span>
                            <span class="distance-value">${distance.toFixed(1)} nm</span>
                        `;
                        redDistances.appendChild(distanceItem);
                    });
                });
            }
        }

        // Initialize the simulator when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.simulator = new TacticalSimulator();
        });
    </script>

 </body></html>